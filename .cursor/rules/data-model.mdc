# Session Viewer Data Model

## Overview

This document defines the canonical data structure for the session viewer UI. This structure is derived from `assets/session-viewer_MOCK.jsx` and has been **fully implemented** in the application.

**Implementation**: See `app/js/data/NodeFactory.js` for node creation and `app/js/data/TreeTransformer.js` for tree building.

## Root Session Object

```typescript
interface Session {
  id: string;              // Unique session identifier
  timestamp: string;       // ISO 8601 session start time
  model: string;           // Claude model used (e.g., "claude-sonnet-4")
  rootMessages: Message[]; // Top-level message nodes
}
```

### Example

```json
{
  "id": "session-001",
  "timestamp": "2025-01-18T14:32:00Z",
  "model": "claude-sonnet-4",
  "rootMessages": [...]
}
```

## Node Types

All nodes in the tree share a common base structure with type-specific extensions.

### Base Node Interface

```typescript
interface BaseNode {
  id: string;           // Unique node identifier (e.g., "msg-1", "tool-1", "subagent-1")
  type: NodeType;       // Node type discriminator
  timestamp: string;    // ISO 8601 timestamp
  children: Node[];     // Child nodes (hierarchical structure)
}

type NodeType = 'user' | 'assistant' | 'tool_call' | 'subagent';
```

## 1. User Message Node

```typescript
interface UserMessage extends BaseNode {
  type: 'user';
  content: string;      // User's message text
}
```

### Example

```json
{
  "id": "msg-1",
  "type": "user",
  "timestamp": "2025-01-18T14:32:00Z",
  "content": "Help me refactor the authentication module to use JWT tokens instead of sessions.",
  "children": [...]
}
```

## 2. Assistant Message Node

```typescript
interface AssistantMessage extends BaseNode {
  type: 'assistant';
  content: string;           // Assistant's response text
  thinking?: string;         // Optional: Extended thinking block
  decision?: Decision;       // Optional: Decision point requiring user input
}

interface Decision {
  type: string;              // Decision type (e.g., "user_confirmation")
  question: string;          // Question presented to user
  options: string[];         // Available options
}
```

### Example (Simple)

```json
{
  "id": "msg-2",
  "type": "assistant",
  "timestamp": "2025-01-18T14:32:05Z",
  "content": "I'll help you refactor the authentication module. Let me first analyze the current implementation.",
  "thinking": "Need to understand current auth flow before proposing changes. Should check for: session management, user model, middleware, routes.",
  "children": [...]
}
```

### Example (With Decision)

```json
{
  "id": "msg-3",
  "type": "assistant",
  "timestamp": "2025-01-18T14:32:15Z",
  "content": "I've analyzed the current implementation. Here's my plan:\n\n1. Create a new JWT utility module\n2. Modify the user model to support refresh tokens\n3. Update the auth middleware\n4. Migrate existing sessions\n\nShould I proceed with this approach?",
  "decision": {
    "type": "user_confirmation",
    "question": "Proceed with JWT migration plan?",
    "options": ["Yes, proceed", "Modify plan", "Cancel"]
  },
  "children": [...]
}
```

## 3. Tool Call Node

```typescript
interface ToolCallNode extends BaseNode {
  type: 'tool_call';
  name: string;              // Tool name (e.g., "read_file", "write_file", "bash")
  status: ToolStatus;        // Execution status
  input: Record<string, any>; // Tool input parameters
  output: string;            // Tool output/result
  duration: number;          // Execution time in milliseconds
  error?: string;            // Optional: Error message if status is 'error'
}

type ToolStatus = 'success' | 'error' | 'running' | 'pending';
```

### Example (Success)

```json
{
  "id": "tool-1",
  "type": "tool_call",
  "name": "read_file",
  "status": "success",
  "timestamp": "2025-01-18T14:32:08Z",
  "input": {
    "path": "src/auth/session.js"
  },
  "output": "export class SessionManager { ... }",
  "duration": 245,
  "children": []
}
```

### Example (Error with Recovery)

```json
{
  "id": "tool-6",
  "type": "tool_call",
  "name": "bash",
  "status": "error",
  "timestamp": "2025-01-18T14:33:28Z",
  "input": {
    "command": "npm test -- --grep \"JWT\""
  },
  "output": "Error: Cannot find module 'jsonwebtoken'",
  "duration": 1523,
  "error": "Missing dependency: jsonwebtoken",
  "children": [
    {
      "id": "tool-7",
      "type": "tool_call",
      "name": "bash",
      "status": "success",
      "timestamp": "2025-01-18T14:33:35Z",
      "input": {
        "command": "npm install jsonwebtoken"
      },
      "output": "added 1 package",
      "duration": 2341,
      "children": []
    }
  ]
}
```

**Key Insight**: Tool calls can have children! When a tool call fails and recovery is attempted, the recovery tool calls become children of the failed tool.

## 4. Sub-Agent Node

```typescript
interface SubAgentNode extends BaseNode {
  type: 'subagent';
  name: string;              // Agent name/mode (e.g., "Code Writer", "Test Writer", "Plan Mode")
  status: ToolStatus;        // Overall agent execution status
  task: string;              // Task description/objective
}
```

### Example

```json
{
  "id": "subagent-1",
  "type": "subagent",
  "name": "Code Writer",
  "status": "success",
  "timestamp": "2025-01-18T14:33:10Z",
  "task": "Create JWT utility module with rate limiting",
  "children": [
    {
      "id": "tool-3",
      "type": "tool_call",
      "name": "write_file",
      "status": "success",
      "timestamp": "2025-01-18T14:33:12Z",
      "input": {
        "path": "src/auth/jwt.js"
      },
      "output": "File created successfully",
      "duration": 156,
      "children": []
    }
  ]
}
```

## Hierarchical Relationships

### Parent-Child Rules

1. **User → Assistant**: User messages contain assistant response(s) as children
2. **Assistant → Tool Calls**: Assistant messages contain tool call(s) as children
3. **Assistant → Sub-Agents**: Assistant messages can contain sub-agent(s) as children
4. **Tool Call → Tool Calls**: Failed tools can have recovery tool calls as children
5. **Tool Call → Sub-Agents**: Tool calls that trigger delegation have sub-agent as child
6. **Sub-Agent → Tool Calls**: Sub-agents contain their own tool calls as children
7. **Sub-Agent → Messages**: Sub-agents can have full message trees (user/assistant) as children

### Nesting Example

```
User Message (msg-1)
└── Assistant Message (msg-2)
    ├── Tool Call (tool-1) [read_file]
    ├── Tool Call (tool-2) [read_file]
    └── Assistant Message (msg-3) [follow-up]
        └── User Message (msg-4) [user responds]
            └── Assistant Message (msg-5)
                ├── Sub-Agent (subagent-1) [Code Writer]
                │   ├── Tool Call (tool-3) [write_file]
                │   └── Tool Call (tool-4) [write_file]
                └── Sub-Agent (subagent-2) [Test Writer]
                    ├── Tool Call (tool-5) [write_file]
                    └── Tool Call (tool-6) [bash] - ERROR
                        ├── Tool Call (tool-7) [bash] - recovery (npm install)
                        └── Tool Call (tool-8) [bash] - retry (tests pass)
```

## Complete Example Structure

```json
{
  "id": "session-001",
  "timestamp": "2025-01-18T14:32:00Z",
  "model": "claude-sonnet-4",
  "rootMessages": [
    {
      "id": "msg-1",
      "type": "user",
      "timestamp": "2025-01-18T14:32:00Z",
      "content": "Help me refactor the authentication module to use JWT tokens instead of sessions.",
      "children": [
        {
          "id": "msg-2",
          "type": "assistant",
          "timestamp": "2025-01-18T14:32:05Z",
          "content": "I'll help you refactor the authentication module. Let me first analyze the current implementation.",
          "thinking": "Need to understand current auth flow before proposing changes. Should check for: session management, user model, middleware, routes.",
          "children": [
            {
              "id": "tool-1",
              "type": "tool_call",
              "name": "read_file",
              "status": "success",
              "timestamp": "2025-01-18T14:32:08Z",
              "input": {
                "path": "src/auth/session.js"
              },
              "output": "export class SessionManager { ... }",
              "duration": 245,
              "children": []
            },
            {
              "id": "tool-2",
              "type": "tool_call",
              "name": "read_file",
              "status": "success",
              "timestamp": "2025-01-18T14:32:10Z",
              "input": {
                "path": "src/auth/middleware.js"
              },
              "output": "export const authMiddleware = (req, res, next) => { ... }",
              "duration": 189,
              "children": []
            },
            {
              "id": "msg-3",
              "type": "assistant",
              "timestamp": "2025-01-18T14:32:15Z",
              "content": "I've analyzed the current implementation. Here's my plan:\n\n1. Create a new JWT utility module\n2. Modify the user model to support refresh tokens\n3. Update the auth middleware\n4. Migrate existing sessions\n\nShould I proceed with this approach?",
              "decision": {
                "type": "user_confirmation",
                "question": "Proceed with JWT migration plan?",
                "options": ["Yes, proceed", "Modify plan", "Cancel"]
              },
              "children": [
                {
                  "id": "msg-4",
                  "type": "user",
                  "timestamp": "2025-01-18T14:33:00Z",
                  "content": "Yes, proceed. Also add rate limiting.",
                  "children": [
                    {
                      "id": "msg-5",
                      "type": "assistant",
                      "timestamp": "2025-01-18T14:33:05Z",
                      "content": "Starting the implementation with rate limiting included.",
                      "children": [
                        {
                          "id": "subagent-1",
                          "type": "subagent",
                          "name": "Code Writer",
                          "status": "success",
                          "timestamp": "2025-01-18T14:33:10Z",
                          "task": "Create JWT utility module with rate limiting",
                          "children": [
                            {
                              "id": "tool-3",
                              "type": "tool_call",
                              "name": "write_file",
                              "status": "success",
                              "timestamp": "2025-01-18T14:33:12Z",
                              "input": {
                                "path": "src/auth/jwt.js"
                              },
                              "output": "File created successfully",
                              "duration": 156,
                              "children": []
                            },
                            {
                              "id": "tool-4",
                              "type": "tool_call",
                              "name": "write_file",
                              "status": "success",
                              "timestamp": "2025-01-18T14:33:15Z",
                              "input": {
                                "path": "src/auth/rateLimit.js"
                              },
                              "output": "File created successfully",
                              "duration": 134,
                              "children": []
                            }
                          ]
                        },
                        {
                          "id": "subagent-2",
                          "type": "subagent",
                          "name": "Test Writer",
                          "status": "running",
                          "timestamp": "2025-01-18T14:33:20Z",
                          "task": "Generate unit tests for JWT module",
                          "children": [
                            {
                              "id": "tool-5",
                              "type": "tool_call",
                              "name": "write_file",
                              "status": "success",
                              "timestamp": "2025-01-18T14:33:22Z",
                              "input": {
                                "path": "tests/auth/jwt.test.js"
                              },
                              "output": "File created successfully",
                              "duration": 201,
                              "children": []
                            },
                            {
                              "id": "tool-6",
                              "type": "tool_call",
                              "name": "bash",
                              "status": "error",
                              "timestamp": "2025-01-18T14:33:28Z",
                              "input": {
                                "command": "npm test -- --grep \"JWT\""
                              },
                              "output": "Error: Cannot find module 'jsonwebtoken'",
                              "duration": 1523,
                              "error": "Missing dependency: jsonwebtoken",
                              "children": [
                                {
                                  "id": "tool-7",
                                  "type": "tool_call",
                                  "name": "bash",
                                  "status": "success",
                                  "timestamp": "2025-01-18T14:33:35Z",
                                  "input": {
                                    "command": "npm install jsonwebtoken"
                                  },
                                  "output": "added 1 package",
                                  "duration": 2341,
                                  "children": []
                                },
                                {
                                  "id": "tool-8",
                                  "type": "tool_call",
                                  "name": "bash",
                                  "status": "success",
                                  "timestamp": "2025-01-18T14:33:45Z",
                                  "input": {
                                    "command": "npm test -- --grep \"JWT\""
                                  },
                                  "output": "✓ 12 tests passed",
                                  "duration": 3102,
                                  "children": []
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

## Transformation Notes

### From JSONL to UI Data Model

The JSONL format (source) differs significantly from the UI data model (target). The transformation is **implemented** in:
- `app/js/data/SessionParser.js` - JSONL → Structured events
- `app/js/data/TreeTransformer.js` - Structured events → Hierarchical tree

Here's how the transformation works:

#### 1. Message Pairing

**JSONL**: Sequential events
```jsonl
{"type": "user", "timestamp": "...", "message": {"content": [{"type": "text", "text": "..."}]}}
{"type": "assistant", "timestamp": "...", "message": {"content": [{"type": "text", "text": "..."}]}}
```

**UI Model**: Hierarchical
```json
{
  "type": "user",
  "content": "...",
  "children": [
    {
      "type": "assistant",
      "content": "...",
      "children": []
    }
  ]
}
```

**Rule**: Assistant events become children of the preceding user event.

#### 2. Tool Use Extraction

**JSONL**: Tool use in assistant content, tool result in separate user event
```jsonl
{"type": "assistant", "message": {"content": [
  {"type": "text", "text": "Let me read that file."},
  {"type": "tool_use", "id": "toolu_xyz", "name": "Read", "input": {"path": "file.txt"}}
]}}
{"type": "user", "message": {"content": [
  {"type": "tool_result", "tool_use_id": "toolu_xyz", "content": "file contents...", "is_error": false}
]}}
```

**UI Model**: Tool call node with input and output
```json
{
  "type": "tool_call",
  "name": "Read",
  "input": {"path": "file.txt"},
  "output": "file contents...",
  "status": "success"
}
```

**Rule**: 
1. Extract tool_use from assistant content → create tool_call node
2. Find matching tool_result by tool_use_id → populate output/status
3. Attach as child of assistant message

#### 3. Thinking Extraction

**JSONL**: Thinking as content item
```json
{"type": "assistant", "message": {"content": [
  {"type": "thinking", "thinking": "reasoning text...", "signature": "abc123"},
  {"type": "text", "text": "response text..."}
]}}
```

**UI Model**: Thinking as property
```json
{
  "type": "assistant",
  "thinking": "reasoning text...",
  "content": "response text..."
}
```

**Rule**: Extract thinking from content array, attach as top-level property.

#### 4. Sub-Agent Detection

**JSONL**: agentId in tool result content
```json
{"type": "tool_result", "tool_use_id": "toolu_abc", "content": "agentId: xyz123\nAgent output..."}
```

**UI Model**: Sub-agent node with nested structure
```json
{
  "type": "subagent",
  "name": "Plan Mode",
  "task": "Design implementation approach",
  "children": [
    // Sub-agent's own message tree
  ]
}
```

**Rule**:
1. Detect `agentId: <id>` pattern in tool result
2. Load sub-agent JSONL file: `<session-id>/subagents/agent-<id>.jsonl`
3. Recursively transform sub-agent events
4. Create subagent node with children

#### 5. Status Determination

**JSONL**: is_error flag
```json
{"type": "tool_result", "is_error": true, "content": "Error message"}
```

**UI Model**: Status enum
```json
{
  "type": "tool_call",
  "status": "error",
  "output": "Error message",
  "error": "Error message"
}
```

**Mapping**:
- `is_error: false` → `status: "success"`
- `is_error: true` → `status: "error"`
- Tool use without result yet → `status: "pending"`
- (Could detect "running" from real-time data)

#### 6. Duration Calculation

**JSONL**: Separate timestamps
```jsonl
{"type": "assistant", "timestamp": "2025-01-18T14:32:01.123Z", "message": {"content": [
  {"type": "tool_use", "id": "toolu_xyz", ...}
]}}
{"type": "user", "timestamp": "2025-01-18T14:32:01.368Z", "message": {"content": [
  {"type": "tool_result", "tool_use_id": "toolu_xyz", ...}
]}}
```

**UI Model**: Duration in milliseconds
```json
{
  "type": "tool_call",
  "duration": 245
}
```

**Calculation**: `result_timestamp - use_timestamp` in milliseconds

## Validation Rules

### Required Fields

**All Nodes**:
- `id` (string, unique within session)
- `type` (one of: 'user', 'assistant', 'tool_call', 'subagent')
- `timestamp` (string, ISO 8601 format)
- `children` (array, can be empty)

**User/Assistant**:
- `content` (string, can be empty but must be present)

**Tool Call**:
- `name` (string, non-empty)
- `status` (one of: 'success', 'error', 'running', 'pending')
- `input` (object)
- `output` (string)
- `duration` (number, milliseconds)

**Sub-Agent**:
- `name` (string, non-empty)
- `status` (one of: 'success', 'error', 'running', 'pending')
- `task` (string, non-empty)

### Optional Fields

- `thinking` (assistant only)
- `decision` (assistant only)
- `error` (tool_call only, present when status is 'error')

### Constraints

1. **Unique IDs**: All node IDs must be unique within a session
2. **Valid Timestamps**: All timestamps must be valid ISO 8601 strings
3. **Chronological Order**: Child timestamps should be >= parent timestamps
4. **Status Consistency**: If tool has error status, error field should be present
5. **Non-negative Duration**: Tool durations must be >= 0

## Extension Points

### Future Additions (Design Considerations)

When extending this data model, consider:

#### 1. Metadata Properties

Could add to session root:
```typescript
interface Session {
  // ... existing fields ...
  metadata?: {
    workspaceContext?: string;     // Project context
    totalTokens?: number;           // Token usage
    totalCost?: number;             // Estimated cost
    fileOperations?: number;        // Count of file ops
    errorCount?: number;            // Total errors
    branch?: string;                // Git branch
  };
}
```

#### 2. Rich Content

Could extend content types:
```typescript
interface AssistantMessage {
  // ... existing fields ...
  content: string | RichContent;  // Support structured content
}

interface RichContent {
  type: 'rich';
  blocks: ContentBlock[];
}

type ContentBlock = 
  | { type: 'text'; text: string }
  | { type: 'code'; language: string; code: string }
  | { type: 'image'; url: string; alt: string }
  | { type: 'table'; headers: string[]; rows: string[][] };
```

#### 3. Performance Metrics

Could add to tool calls:
```typescript
interface ToolCallNode {
  // ... existing fields ...
  metrics?: {
    peakMemory?: number;         // Memory usage
    cpuTime?: number;             // CPU time
    networkRequests?: number;     // Network calls
    retries?: number;             // Retry count
  };
}
```

#### 4. User Feedback

Could add to messages:
```typescript
interface BaseNode {
  // ... existing fields ...
  feedback?: {
    rating?: number;              // 1-5 stars
    helpful?: boolean;            // Helpful/not helpful
    comment?: string;             // User comment
    timestamp?: string;           // When feedback given
  };
}
```

#### 5. Annotations

Could add to any node:
```typescript
interface BaseNode {
  // ... existing fields ...
  annotations?: Annotation[];
}

interface Annotation {
  id: string;
  type: 'note' | 'highlight' | 'bookmark' | 'tag';
  content: string;
  author?: string;
  timestamp: string;
}
```

#### 6. Agent Context

For sub-agents, could add:
```typescript
interface SubAgentNode {
  // ... existing fields ...
  context?: {
    mode: 'plan' | 'debug' | 'ask';     // Agent mode
    parentTask?: string;                 // Context from parent
    constraints?: string[];              // Execution constraints
    permissions?: string[];              // What agent can do
  };
}
```

## Usage Examples

### Flattening Tree for Sequential View

```typescript
function flattenTree(nodes: Node[], depth = 0): FlatNode[] {
  const result: FlatNode[] = [];
  
  nodes.forEach((node, index) => {
    result.push({ ...node, depth, index });
    
    if (node.children?.length) {
      result.push(...flattenTree(node.children, depth + 1));
    }
  });
  
  return result;
}

const flatNodes = flattenTree(session.rootMessages);
```

### Filtering by Type

```typescript
function filterByType(nodes: Node[], type: NodeType): Node[] {
  const result: Node[] = [];
  
  for (const node of nodes) {
    if (node.type === type) {
      result.push(node);
    }
    
    if (node.children?.length) {
      result.push(...filterByType(node.children, type));
    }
  }
  
  return result;
}

const allToolCalls = filterByType(session.rootMessages, 'tool_call');
```

### Calculating Statistics

```typescript
interface SessionStats {
  totalNodes: number;
  byType: Record<NodeType, number>;
  maxDepth: number;
  toolCallStats: {
    total: number;
    success: number;
    error: number;
    avgDuration: number;
    totalDuration: number;
  };
}

function calculateStats(nodes: Node[], depth = 0): SessionStats {
  // Implementation...
}
```

### Searching Content

```typescript
function searchContent(nodes: Node[], query: string): Node[] {
  const results: Node[] = [];
  const lowerQuery = query.toLowerCase();
  
  for (const node of nodes) {
    let matches = false;
    
    if ('content' in node && node.content.toLowerCase().includes(lowerQuery)) {
      matches = true;
    }
    
    if ('task' in node && node.task.toLowerCase().includes(lowerQuery)) {
      matches = true;
    }
    
    if (matches) {
      results.push(node);
    }
    
    if (node.children?.length) {
      results.push(...searchContent(node.children, query));
    }
  }
  
  return results;
}
```

## Summary

This data model represents:

1. **Hierarchical Structure**: Parent-child relationships preserve conversation flow
2. **Chronological Order**: Timestamps enable temporal navigation
3. **Type Safety**: Discriminated unions for different node types
4. **Complete Context**: All information needed for visualization
5. **Extensible**: Clear extension points for future features

All data wrangling logic should target this structure as the canonical output format.
